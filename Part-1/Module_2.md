---
layout: default
title: Module 2
parent: Part 1
nav_order: 4
description: "Module 2 of Nand2Tetris."
permalink: /Part1/Module_2
has_children: false
includes:
  - head_custom.html
---

# Nand2Tetris: Module 2 - Boolean Arithematic

Module 2 of the Nand2Tetris course dives deep into these foundational concepts, providing an in-depth look at how computers perform basic arithmetic operations using binary numbers. Below is a breakdown of the key units in this module:

## Unit 2.1: Binary Numbers

Binary numbers form the core of computer systems. Unlike our everyday decimal system, which is based on ten digits (0-9), binary uses only two digits: 0 and 1. These binary digits, or bits, are the smallest unit of data in computing. This unit introduces the basics of binary representation, explaining how bits work together to form numbers. 

Converting between binary and decimal systems is a crucial skill for anyone learning about computer architecture. In this unit, you'll learn how to convert decimal numbers into binary and vice versa, laying the groundwork for understanding how computers store and process data.

### Conversion of Decimal to Binary

To convert a decimal number to binary, you repeatedly divide the number by 2 and record the remainders. For example:

**Convert decimal number 13 to binary:**

1. 13 ÷ 2 = 6, remainder = 1
2. 6 ÷ 2 = 3, remainder = 0
3. 3 ÷ 2 = 1, remainder = 1
4. 1 ÷ 2 = 0, remainder = 1

Reading the remainders from bottom to top, we get: **1101** (binary).

### Conversion of Binary to Decimal

To convert a binary number to decimal, You multiply each bit by 2 raised to the power of its position (starting from 0 on the right) and sum the results. For example:

**Convert binary number 1101 to decimal:**

1. (1 * 2^3) + (1 * 2^2) + (0 * 2^1) + (1 * 2^0)
2. = (1 * 8) + (1 * 4) + (0 * 2) + (1 * 1)
3. = 8 + 4 + 0 + 1
4. = 13 (decimal)

Thus, the binary number **1101** is equivalent to **13** in decimal.


## Unit 2.2: Binary Addition

Just like in decimal arithmetic, adding binary numbers involves carrying over when the sum exceeds the base (in this case, base-2). This unit covers the essential concepts of binary addition, including how to handle carries and how to add multiple binary numbers together. You'll practice adding simple binary numbers and understand how the carry process works in a similar way to decimal addition. This is a key operation that underpins all digital arithmetic.

### Example of Binary Addition

**Add 1011 (11 in decimal) and 1101 (13 in decimal):**

1. Start from the right: 1 + 1 = 10, write down 0 and carry over 1.
2. Next column: 1 + 0 + 1 (carry) = 10, write down 0 and carry over 1.
3. Next column: 0 + 1 + 1 (carry) = 10, write down 0 and carry over 1.
4. Leftmost column: 1 + 1 (carry) = 10, write down 0 and carry over 1.
5. Final carry: Write down 1.

Result: **11000** (24 in decimal).

### Half Adder

A **half adder** is a simple circuit that adds two single-bit binary numbers, producing a sum and a carry output. It consists of two logic gates: an **XOR gate** and an **AND gate**.

- The **XOR gate** is used to generate the sum output.
- The **AND gate** is used to generate the carry output.

#### Half Adder Truth Table

Here is the truth table for a half adder, which shows all possible input combinations and their corresponding sum and carry outputs:

| A (Input 1) | B (Input 2) | Sum (S) | Carry (C) |
|:-----------:|:-----------:|:-------:|:---------:|
|      0      |      0      |    0    |     0     |
|      0      |      1      |    1    |     0     |
|      1      |      0      |    1    |     0     |
|      1      |      1      |    0    |     1     |

- **Sum (S)**: This is the result of the addition of A and B. The sum is 1 when either A or B is 1, but not both.
- **Carry (C)**: This indicates whether there is a carry from the addition. The carry is 1 when both A and B are 1.

#### Half Adder Logic

The logic for the sum and carry outputs can be defined as follows:

- **Sum (S)**: The sum output is generated by an **XOR** gate:
  - \( S = A \oplus B \)
  - The sum is 1 when one of the inputs is 1, but not both.

- **Carry (C)**: The carry output is generated by an **AND** gate:
  - \( C = A \land B \)
  - The carry is 1 only when both inputs are 1.

### Full Adder

A **full adder** is a more advanced circuit that adds three binary digits: two single-bit binary numbers and a carry input from a previous addition. It produces a sum and a carry output, similar to the half adder but with an additional carry input.

A full adder consists of two **half adders** and an **OR gate** to combine the carry outputs from the two half adders.

#### Full Adder Truth Table

Here is the truth table for a full adder, which shows all possible input combinations and their corresponding sum and carry outputs. The inputs are **A**, **B**, and **Cin** (carry input from a previous addition).

| A (Input 1) | B (Input 2) | Cin (Carry In) | Sum (S) | Carry Out (Cout) |
|:-----------:|:-----------:|:--------------:|:-------:|:----------------:|
|      0      |      0      |       0        |    0    |        0         |
|      0      |      0      |       1        |    1    |        0         |
|      0      |      1      |       0        |    1    |        0         |
|      0      |      1      |       1        |    0    |        1         |
|      1      |      0      |       0        |    1    |        0         |
|      1      |      0      |       1        |    0    |        1         |
|      1      |      1      |       0        |    0    |        1         |
|      1      |      1      |       1        |    1    |        1         |

- **Sum (S)**: The sum output is the result of adding the three input bits. It represents the least significant bit of the total sum.
- **Carry Out (Cout)**: The carry output is set to 1 when the addition results in a carry beyond the current bit position.

#### Full Adder Logic

The full adder can be constructed using two half adders and an OR gate. Here's how the logic works:

1. **Half Adder 1**: The first half adder adds **A** and **B**:
   - **Sum1** = \( A \oplus B \)
   - **Carry1** = \( A \land B \)

2. **Half Adder 2**: The second half adder adds **Sum1** (from the first half adder) and the carry input **Cin**:
   - **Sum** = \( Sum1 \oplus Cin \)
   - **Carry2** = \( Sum1 \land Cin \)

3. **Final Carry**: The final carry output is generated by an **OR gate** that combines the carry outputs from the two half adders:
   - **Cout** = \( Carry1 \lor Carry2 \)

Thus, the full adder logic can be expressed as:

- **Sum (S)** = \( (A \oplus B) \oplus Cin \)
- **Carry Out (Cout)** = \( (A \land B) \lor ((A \oplus B) \land Cin) \)

## Unit 2.3: Negative Numbers

In computing, it's crucial to represent not just positive numbers but also negative values. This unit explores how negative numbers are represented in binary systems, specifically using the two's complement method. Two's complement is a widely used technique because it simplifies the operations for both addition and subtraction of signed numbers.

### Note: Signed Integers

In computer systems, numbers can be categorized into **signed** and **unsigned** types. A **signed integer** is a variable that can store both positive and negative numbers, whereas an **unsigned integer** can only store non-negative numbers (zero and positive values).

The term **signed** refers to the ability to represent both positive and negative values. Signed integers typically use one bit (the most significant bit, or MSB) to indicate the sign of the number. If the MSB is 0, the number is positive, and if the MSB is 1, the number is negative. This is commonly achieved using methods such as **two's complement**, where negative numbers are represented in a way that allows for efficient arithmetic operations.

For example, in an 8-bit signed integer:
- The binary number `01111111` represents +127 (the largest positive value).
- The binary number `10000000` represents -128 (the smallest negative value).
- The binary number `00000001` represents +1, while `11111111` represents -1.

Signed integers are essential in computations where both positive and negative values are needed, such as representing temperatures, financial transactions, and any other application where values can be negative.

### Example: Two's Complement

To find the two's complement of a number, follow these steps:

1. Write the binary representation of the number.
2. Invert all the bits (flip 0s to 1s and 1s to 0s).
3. Add 1 to the result.

**Find the two's complement of 5 (binary 0101):**

1. Start with 5: **0101**
2. Invert the bits: **1010**
3. Add 1: **1010 + 1 = 1011**

The two's complement representation of -5 is **1011**.

## Unit 2.4: Arithmetic Logic Unit (ALU)

The **Arithmetic Logic Unit (ALU)** is a fundamental component of a computer's central processing unit (CPU). It is responsible for performing both **arithmetic** and **logical** operations on binary numbers. The ALU operates at the heart of computational processes and is essential for handling the data manipulation tasks required for virtually every computing application.

### Functions of the ALU

The ALU performs a variety of operations, including:

1. **Arithmetic Operations**:
   - **Addition**: The ALU can add binary numbers together. This involves handling carries and performing operations similar to how addition works in the decimal system.
   - **Subtraction**: Subtraction is typically implemented using two's complement, where the negative operand is represented in two's complement form, and the ALU performs an addition operation on the two operands.
   - **Multiplication**: Some ALUs can multiply binary numbers, though more complex multiplications may involve iterative addition.
   - **Division**: Similar to multiplication, division can also be implemented using subtraction or other methods in more advanced ALUs.

2. **Logical Operations**:
   - **AND**: The ALU can perform the logical AND operation, where each bit of two binary numbers is compared and the result is 1 if both bits are 1.
   - **OR**: The OR operation is used to combine two binary numbers, where each bit of the result is 1 if at least one of the corresponding bits of the operands is 1.
   - **XOR (Exclusive OR)**: This operation returns 1 when only one of the corresponding bits is 1, but not both.
   - **NOT**: The NOT operation inverts the bits of a number, turning 0s into 1s and vice versa.

### How the ALU Works

The ALU takes two input values (operands) and a control signal that specifies the operation to perform. Depending on the operation requested, the ALU will compute the result and send it to the next stage of the processor for further processing or storage.

#### Data Signals

The ALU's operation takes 2 input `x` and `y`.

#### Control Signals

The ALU's operation is controlled by the following control signals:

1. **zx** (Zero A): This signal is used to zero out the first operand (A). If `zx = 1`, the ALU treats operand A as zero during the operation.
   - **zx = 1**: Set operand A to 0.
   - **zx = 0**: Keep operand A as it is.

2. **nx** (Negate A): This signal is used to negate the first operand (A). If `nx = 1`, the ALU flips all the bits of operand A, performing a bitwise NOT operation.
   - **nx = 1**: Negate operand A (bitwise NOT).
   - **nx = 0**: Keep operand A unchanged.

3. **zy** (Zero B): This signal is used to zero out the second operand (B). If `zy = 1`, operand B is treated as zero during the operation.
   - **zy = 1**: Set operand B to 0.
   - **zy = 0**: Keep operand B as it is.

4. **ny** (Negate B): This signal is used to negate the second operand (B). If `ny = 1`, the ALU flips all the bits of operand B.
   - **ny = 1**: Negate operand B (bitwise NOT).
   - **ny = 0**: Keep operand B unchanged.

5. **f** (Function): This signal determines whether the ALU will perform an arithmetic operation or a logical operation.
   - **f = 1**: Perform an arithmetic operation (e.g., addition, subtraction).
   - **f = 0**: Perform a logical operation (e.g., AND, OR, XOR).

6. **n** (Negate Output): This signal is used to negate the output of the ALU. If `n = 1`, the result of the ALU operation is inverted.
   - **n = 1**: Negate the output.
   - **n = 0**: Keep the output as it is.

These control signals together define how the ALU manipulates the input operands and determines the final result of the operation.

**NOTE: The ALU follows the above in order. We can't do this in any order**

#### Example: ALU Addition with Control and Output Signals

Let’s walk through the example of adding two binary numbers, **1011** (11 in decimal) and **1101** (13 in decimal), in the ALU. Assume the control signals are set as follows:

zx = 0    (do not zero out A)
nx = 0    (do not negate A)
zy = 0    (do not zero out B)
ny = 0    (do not negate B)
f  = 1    (perform addition)
n  = 0    (do not negate the output)

**Operands**:

A = 1011 (11 in decimal)
B = 1101 (13 in decimal)

The ALU performs the addition:

The output of the ALU is **11000** (24 in decimal). Along with the result, the ALU generates the following output signals:

- **Out**: 11000 (result of addition)
- **Zero Flag (Z)**: 0 (since the result is not zero)
- **Negative Flag (N)**: 0 (since the result is positive)
- **Carry Flag (C)**: 1 (since there was a carry from the most significant bit)
- **Overflow Flag (V)**: 0 (no overflow occurred)
- **Equal Flag (EQ)**: 0 (the operands were not equal)

These status flags allow the CPU to make further decisions based on the result of the operation, such as branching to another part of a program or adjusting the program's execution flow.
